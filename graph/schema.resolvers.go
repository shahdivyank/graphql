package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"graphql/graph/model"
	"log"
	"os"
	"time"

	"github.com/google/uuid"
)

// AddBeat is the resolver for the add_beat field.
func (r *mutationResolver) AddBeat(ctx context.Context, input model.NewBeat) (*model.Beat, error) {
	id := uuid.New()

	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	beatdrop := &model.Beat{
		ID:          id,
		User:        &user,
		Song:        input.Song,
		Artist:      input.Artist,
		Description: input.Description,
		Location:    input.Location,
		Longitude:   input.Longitude,
		Latitude:    input.Latitude,
		Image:       input.Image,
		Timestamp:   time.Now().UTC(),
		Comments:    0,
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO beats (id, userid, song, artist, description, location, longitude, latitude, image, timestamp, comments) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`,
		beatdrop.ID, beatdrop.User.ID, beatdrop.Song, beatdrop.Artist, beatdrop.Description, beatdrop.Location, beatdrop.Longitude, beatdrop.Latitude, beatdrop.Image, beatdrop.Timestamp, beatdrop.Comments)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return beatdrop, nil
}

// AddNewUser is the resolver for the add_new_user field.
func (r *mutationResolver) AddNewUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	id := uuid.New()

	user := &model.User{
		ID:        id,
		Name:      input.Name,
		Username:  input.Username,
		Bio:       input.Bio,
		Beatdrops: 0,
		Friends:   0,
		Settings:  `{}`,
		Photo:     "",
		Timestamp: time.Now().UTC(),
	}

	_, err := r.db.Exec(context.Background(), `INSERT INTO users (id, name, username, bio, beatdrops, friends, settings, photo) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
		user.ID, user.Name, user.Username, user.Bio, user.Beatdrops, user.Friends, user.Settings, user.Photo)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return user, nil
}

// AddComment is the resolver for the add_comment field.
func (r *mutationResolver) AddComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1;", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	var beat model.Beat
	err = r.db.QueryRow(context.Background(), "SELECT id, location, timestamp, song, artist, description, longitude, latitude FROM beats WHERE id = $1;", input.Beat).Scan(&beat.ID, &beat.Location, &beat.Timestamp, &beat.Song, &beat.Artist, &beat.Description, &beat.Longitude, &beat.Latitude)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	id := uuid.New()

	comment := &model.Comment{
		ID:        id,
		Timestamp: time.Now().UTC(),
		User:      &user,
		Beat:      &beat,
		Comment:   input.Comment,
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO comments (id, userid, beatid, timestamp, comment) VALUES ($1, $2, $3, $4, $5)`,
		id, input.User, input.Beat, comment.Timestamp, comment.Comment)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return comment, nil
}

// UpdateBio is the resolver for the update_bio field.
func (r *mutationResolver) UpdateBio(ctx context.Context, input model.UpdateBio) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE users SET bio = $1 WHERE id = $2;`, input.Bio, input.User)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// UpdateUsername is the resolver for the update_username field.
func (r *mutationResolver) UpdateUsername(ctx context.Context, input model.UpdateUsername) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE users SET username = $1 WHERE id = $2;`, input.Username, input.User)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// AddFriend is the resolver for the add_friend field.
func (r *mutationResolver) AddFriend(ctx context.Context, input model.NewFriend) (string, error) {
	id := uuid.New()

	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1;", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	var friend model.User
	err = r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1;", input.Friend).Scan(&friend.ID, &friend.Name, &friend.Username, &friend.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	sender := user.ID

	friendship := &model.Friend{
		ID:        id,
		Alpha:     &user,
		Beta:      &friend,
		Timestamp: time.Now().UTC(),
		Sender:    sender,
		Status:    0,
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO friends (id, alpha, beta, timestamp, status, sender) VALUES ($1, GREATEST($2::uuid, $3::uuid), LEAST($2::uuid, $3::uuid), $4, $5, $6)`,
		friendship.ID, friendship.Alpha.ID, friendship.Beta.ID, friendship.Timestamp, friendship.Status, friendship.Sender)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// AcceptFriend is the resolver for the accept_friend field.
func (r *mutationResolver) AcceptFriend(ctx context.Context, input model.AcceptFriend) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE friends SET status = 1 WHERE id = $1;`, input.ID)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// DenyFriend is the resolver for the deny_friend field.
func (r *mutationResolver) DenyFriend(ctx context.Context, input model.DenyFriend) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE friends SET status = -1 WHERE id = $1;`, input.ID)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, name string) ([]*model.User, error) {
	rows, err := r.db.Query(context.Background(), `
		SELECT id, name, username, bio, photo 
		FROM users 
		WHERE name ILIKE '%' || $1 || '%'
   			OR username ILIKE '%' || $1 || '%'`, name)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var users []*model.User

	for rows.Next() {
		var user model.User

		if err := rows.Scan(&user.ID, &user.Name, &user.Username, &user.Bio, &user.Photo); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		users = append(users, &user)
	}

	return users, nil
}

// Beats is the resolver for the beats field.
func (r *queryResolver) Beats(ctx context.Context, id uuid.UUID) ([]*model.Beat, error) {
	rows, err := r.db.Query(context.Background(), `
	SELECT 
        b.id, b.timestamp, b.location, b.song, b.artist, b.description,
        b.longitude, b.latitude, b.image, b.comments,
        u.id, u.name, u.username, u.bio
    FROM beats b
    JOIN users u ON b.userid = u.id
    LEFT JOIN friends f
        ON (
            (f.alpha = $1 AND f.beta = b.userid) OR
            (f.beta = $1 AND f.alpha = b.userid)
        )
    WHERE f.status = 1 OR b.userid = $1
	ORDER BY b.timestamp DESC;
	`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var beats []*model.Beat

	for rows.Next() {
		var beat model.Beat
		beat.User = &model.User{}

		if err := rows.Scan(
			&beat.ID,
			&beat.Timestamp,
			&beat.Location,
			&beat.Song,
			&beat.Artist,
			&beat.Description,
			&beat.Longitude,
			&beat.Latitude,
			&beat.Image,
			&beat.Comments,
			&beat.User.ID,
			&beat.User.Name,
			&beat.User.Username,
			&beat.User.Bio); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		beats = append(beats, &beat)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return beats, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*model.User, error) {
	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio, timestamp FROM users WHERE id = $1", id).Scan(&user.ID, &user.Name, &user.Username, &user.Bio, &user.Timestamp)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return &user, nil
}

// Beatdrop is the resolver for the beatdrop field.
func (r *queryResolver) Beatdrop(ctx context.Context, id uuid.UUID) (*model.Beat, error) {
	var beat model.Beat
	beat.User = &model.User{}

	err := r.db.QueryRow(context.Background(), `
	SELECT 
		b.id,
		b.userid,
		b.timestamp,
		b.location,
		b.song,
		b.artist,
		b.description,
		b.longitude,
		b.latitude,
		b.image,
		b.comments,
		u.id,
		u.name,
		u.username,
		u.bio
	FROM beats b
	JOIN users u ON b.userid = u.id
	WHERE b.id = $1;`, id).Scan(&beat.ID,
		&beat.User.ID,
		&beat.Timestamp,
		&beat.Location,
		&beat.Song,
		&beat.Artist,
		&beat.Description,
		&beat.Longitude,
		&beat.Latitude,
		&beat.Image,
		&beat.Comments,
		&beat.User.ID,
		&beat.User.Name,
		&beat.User.Username,
		&beat.User.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return &beat, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, id uuid.UUID) ([]*model.Comment, error) {
	rows, err := r.db.Query(context.Background(), `
	 SELECT
        c.id,
        c.timestamp,
        u.id,
        u.name,
        u.username,
        u.bio,
        c.comment
    FROM comments c
    JOIN users u ON c.userid = u.id
    WHERE c.beatid = $1
	ORDER BY c.timestamp DESC;
	`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var comments []*model.Comment

	for rows.Next() {
		var comment model.Comment
		comment.User = &model.User{}

		if err := rows.Scan(
			&comment.ID, &comment.Timestamp, &comment.User.ID, &comment.User.Name, &comment.User.Username, &comment.User.Bio, &comment.Comment); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		comments = append(comments, &comment)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return comments, nil
}

// Beatdrops is the resolver for the beatdrops field.
func (r *queryResolver) Beatdrops(ctx context.Context, id uuid.UUID) ([]*model.Beat, error) {
	rows, err := r.db.Query(context.Background(), `
	SELECT 
		id,
		timestamp,
		location,
		song,
		artist,
		description,
		longitude,
		latitude,
		image,
		comments
	FROM beats WHERE userid = $1;`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var beats []*model.Beat

	for rows.Next() {
		var beat model.Beat
		beat.User = &model.User{}

		if err := rows.Scan(&beat.ID,
			&beat.Timestamp,
			&beat.Location,
			&beat.Song,
			&beat.Artist,
			&beat.Description,
			&beat.Longitude,
			&beat.Latitude,
			&beat.Image,
			&beat.Comments,
		); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		beats = append(beats, &beat)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return beats, nil
}

// Friends is the resolver for the friends field.
func (r *queryResolver) Friends(ctx context.Context, id uuid.UUID, status int32) ([]*model.Friend, error) {
	rows, err := r.db.Query(ctx, `
		SELECT f.id, u.id, u.name, u.username, u.bio, u.photo, f.status, f.sender
		FROM friends f
		JOIN users u 
		  ON u.id = CASE WHEN f.alpha = $1 THEN f.beta ELSE f.alpha END
		WHERE (f.alpha = $1 OR f.beta = $1) AND f.status = $2`, id, status)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var friends []*model.Friend
	for rows.Next() {
		var friend model.Friend
		friend.Beta = &model.User{}

		if err := rows.Scan(
			&friend.ID,
			&friend.Beta.Name,
			&friend.Beta.Name,
			&friend.Beta.Username,
			&friend.Beta.Bio,
			&friend.Beta.Photo,
			&friend.Status,
			&friend.Sender,
		); err != nil {
			return nil, fmt.Errorf("scan failed: %w", err)
		}
		friends = append(friends, &friend)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return friends, nil
}

// Activity is the resolver for the activity field.
func (r *queryResolver) Activity(ctx context.Context, id uuid.UUID) ([]*model.Activity, error) {
	rows, err := r.db.Query(context.Background(), `
	 SELECT
        c.id,
        c.timestamp,
		b.id, 
		b.image,
        u.id,
        u.name,
        u.username,
        u.bio,
        c.comment
    FROM comments c
    JOIN beats b ON c.beatid = b.id
	JOIN users u ON c.userid = u.id
    WHERE c.userid != $1
	ORDER BY c.timestamp DESC;`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var activities []*model.Activity

	for rows.Next() {
		var activity model.Activity
		activity.User = &model.User{}
		activity.Beat = &model.Beat{}

		if err := rows.Scan(
			&activity.ID, &activity.Timestamp, &activity.Beat.ID, &activity.Beat.Image, &activity.User.ID, &activity.User.Name, &activity.User.Username, &activity.User.Bio, &activity.Content); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		activities = append(activities, &activity)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return activities, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
