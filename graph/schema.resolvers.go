package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"graphql/graph/model"
	"log"
	"os"
	"time"

	"github.com/google/uuid"
)

// AddBeat is the resolver for the add_beat field.
func (r *mutationResolver) AddBeat(ctx context.Context, input model.NewBeat) (*model.Beat, error) {
	id := uuid.New()

	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	beatdrop := &model.Beat{
		ID:          id,
		User:        &user,
		Song:        input.Song,
		Artist:      input.Artist,
		Description: input.Description,
		Location:    input.Location,
		Longitude:   input.Longitude,
		Latitude:    input.Latitude,
		Timestamp:   int32(time.Now().Unix()),
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO beats (id, userid, song, artist, description, location, longitude, latitude, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
		beatdrop.ID, beatdrop.User.ID, beatdrop.Song, beatdrop.Artist, beatdrop.Description, beatdrop.Location, beatdrop.Longitude, beatdrop.Latitude, beatdrop.Timestamp)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return beatdrop, nil
}

// AddNewUser is the resolver for the add_new_user field.
func (r *mutationResolver) AddNewUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	id := uuid.New()

	user := &model.User{
		ID:       id,
		Name:     input.Name,
		Username: input.Username,
		Bio:      input.Bio,
	}

	_, err := r.db.Exec(context.Background(), `INSERT INTO users (id, name, username, bio) VALUES ($1, $2, $3, $4)`,
		user.ID, user.Name, user.Username, user.Bio)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return user, nil
}

// AddComment is the resolver for the add_comment field.
func (r *mutationResolver) AddComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1;", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	var beat model.Beat
	err = r.db.QueryRow(context.Background(), "SELECT id, location, timestamp, song, artist, description, longitude, latitude FROM beats WHERE id = $1;", input.Beat).Scan(&beat.ID, &beat.Location, &beat.Timestamp, &beat.Song, &beat.Artist, &beat.Description, &beat.Longitude, &beat.Latitude)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	id := uuid.New()

	comment := &model.Comment{
		ID:        id,
		Timestamp: int32(time.Now().Unix()),
		User:      &user,
		Beat:      &beat,
		Comment:   input.Comment,
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO comments (id, userid, beatid, timestamp, comment) VALUES ($1, $2, $3, $4, $5)`,
		id, user.ID, beat.ID, comment.Timestamp, comment.Comment)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return comment, nil
}

// Beats is the resolver for the beats field.
func (r *queryResolver) Beats(ctx context.Context) ([]*model.Beat, error) {
	rows, err := r.db.Query(context.Background(), `
	SELECT 
		b.id,
		b.userid,
		b.timestamp,
		b.location,
		b.song,
		b.artist,
		b.description,
		b.longitude,
		b.latitude,
		u.id,
		u.name,
		u.username,
		u.bio
	FROM beats b
	JOIN users u ON b.userid = u.id
	`)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var beats []*model.Beat

	for rows.Next() {
		var beat model.Beat
		beat.User = &model.User{}

		if err := rows.Scan(&beat.ID,
			&beat.User.ID,
			&beat.Timestamp,
			&beat.Location,
			&beat.Song,
			&beat.Artist,
			&beat.Description,
			&beat.Longitude,
			&beat.Latitude,
			&beat.User.ID,
			&beat.User.Name,
			&beat.User.Username,
			&beat.User.Bio); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		beats = append(beats, &beat)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return beats, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	rows, err := r.db.Query(context.Background(), "SELECT * FROM users")

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var users []*model.User
	for rows.Next() {
		var user model.User
		if err := rows.Scan(&user.ID, &user.Name, &user.Username, &user.Bio); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}
		users = append(users, &user)
	}

	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*model.User, error) {
	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1", id).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return &user, nil
}

// Beatdrop is the resolver for the beatdrop field.
func (r *queryResolver) Beatdrop(ctx context.Context, id uuid.UUID) (*model.Beat, error) {
	var beat model.Beat
	beat.User = &model.User{}

	err := r.db.QueryRow(context.Background(), `
	SELECT 
		b.id,
		b.userid,
		b.timestamp,
		b.location,
		b.song,
		b.artist,
		b.description,
		b.longitude,
		b.latitude,
		u.id,
		u.name,
		u.username,
		u.bio
	FROM beats b
	JOIN users u ON b.userid = u.id
	WHERE b.id = $1;`, id).Scan(&beat.ID,
		&beat.User.ID,
		&beat.Timestamp,
		&beat.Location,
		&beat.Song,
		&beat.Artist,
		&beat.Description,
		&beat.Longitude,
		&beat.Latitude,
		&beat.User.ID,
		&beat.User.Name,
		&beat.User.Username,
		&beat.User.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return &beat, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, id uuid.UUID) ([]*model.Comment, error) {
	rows, err := r.db.Query(context.Background(), `
	 SELECT
        c.id,
        c.timestamp,
        u.id,
        u.name,
        u.username,
        u.bio,
        c.comment
    FROM comments c
    JOIN users u ON c.userid = u.id
    WHERE c.beatid = $1
	`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var comments []*model.Comment

	for rows.Next() {
		var comment model.Comment
		comment.User = &model.User{}

		if err := rows.Scan(
			&comment.ID, &comment.Timestamp, &comment.User.ID, &comment.User.Name, &comment.User.Username, &comment.User.Bio, &comment.Comment); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		comments = append(comments, &comment)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return comments, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
