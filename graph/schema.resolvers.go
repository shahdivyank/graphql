package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"graphql/graph/model"
	"log"
	"os"
	"time"

	"github.com/google/uuid"
)

// AddBeat is the resolver for the add_beat field.
func (r *mutationResolver) AddBeat(ctx context.Context, input model.NewBeat) (*model.Beat, error) {
	id := uuid.New()

	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	beatdrop := &model.Beat{
		ID:          id,
		User:        &user,
		Song:        input.Song,
		Artist:      input.Artist,
		Description: input.Description,
		Location:    input.Location,
		Longitude:   input.Longitude,
		Latitude:    input.Latitude,
		Timestamp:   int32(time.Now().Unix()),
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO beats (id, userid, song, artist, description, location, longitude, latitude, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
		beatdrop.ID, beatdrop.User.ID, beatdrop.Song, beatdrop.Artist, beatdrop.Description, beatdrop.Location, beatdrop.Longitude, beatdrop.Latitude, beatdrop.Timestamp)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return beatdrop, nil
}

// AddNewUser is the resolver for the add_new_user field.
func (r *mutationResolver) AddNewUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	id := uuid.New()

	user := &model.User{
		ID:        id,
		Name:      input.Name,
		Username:  input.Username,
		Bio:       input.Bio,
		Beatdrops: 0,
		Friends:   0,
		Settings:  `{}`,
		Photo:     "",
	}

	_, err := r.db.Exec(context.Background(), `INSERT INTO users (id, name, username, bio, beatdrops, friends, settings, photo) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
		user.ID, user.Name, user.Username, user.Bio, user.Beatdrops, user.Friends, user.Settings, user.Photo)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return user, nil
}

// AddComment is the resolver for the add_comment field.
func (r *mutationResolver) AddComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1;", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	var beat model.Beat
	err = r.db.QueryRow(context.Background(), "SELECT id, location, timestamp, song, artist, description, longitude, latitude FROM beats WHERE id = $1;", input.Beat).Scan(&beat.ID, &beat.Location, &beat.Timestamp, &beat.Song, &beat.Artist, &beat.Description, &beat.Longitude, &beat.Latitude)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	id := uuid.New()

	comment := &model.Comment{
		ID:        id,
		Timestamp: int32(time.Now().Unix()),
		User:      &user,
		Beat:      &beat,
		Comment:   input.Comment,
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO comments (id, userid, beatid, timestamp, comment) VALUES ($1, $2, $3, $4, $5)`,
		id, input.User, input.Beat, comment.Timestamp, comment.Comment)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return comment, nil
}

// UpdateBio is the resolver for the update_bio field.
func (r *mutationResolver) UpdateBio(ctx context.Context, input model.UpdateBio) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE users SET bio = $1 WHERE id = $2;`, input.Bio, input.User)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// UpdateUsername is the resolver for the update_username field.
func (r *mutationResolver) UpdateUsername(ctx context.Context, input model.UpdateUsername) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE users SET username = $1 WHERE id = $2;`, input.Username, input.User)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// AddFriend is the resolver for the add_friend field.
func (r *mutationResolver) AddFriend(ctx context.Context, input *model.NewFriend) (string, error) {
	id := uuid.New()

	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1;", input.User).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	var friend model.User
	err = r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1;", input.Friend).Scan(&friend.ID, &friend.Name, &friend.Username, &friend.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	friendship := &model.Friend{
		ID:        id,
		Alpha:     &user,
		Beta:      &friend,
		Timestamp: int32(time.Now().Unix()),
		Status:    0,
	}

	_, err = r.db.Exec(context.Background(), `INSERT INTO friends (id, alpha, beta, timestamp, status) VALUES ($1, $2, $3, $4, $5)`,
		friendship.ID, friendship.Alpha.ID, friendship.Beta.ID, friendship.Timestamp, friendship.Status)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// AcceptFriend is the resolver for the accept_friend field.
func (r *mutationResolver) AcceptFriend(ctx context.Context, input *model.AcceptFriend) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE friends SET status = 1 WHERE id = $1;`, input.ID)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil
}

// DenyFriend is the resolver for the deny_friend field.
func (r *mutationResolver) DenyFriend(ctx context.Context, input *model.DenyFriend) (string, error) {
	_, err := r.db.Exec(context.Background(), `UPDATE friends SET status = -1 WHERE id = $1;`, input.ID)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	return "ok", nil

}

// Beats is the resolver for the beats field.
func (r *queryResolver) Beats(ctx context.Context) ([]*model.Beat, error) {
	rows, err := r.db.Query(context.Background(), `
	SELECT 
		b.id,
		b.userid,
		b.timestamp,
		b.location,
		b.song,
		b.artist,
		b.description,
		b.longitude,
		b.latitude,
		u.id,
		u.name,
		u.username,
		u.bio
	FROM beats b
	JOIN users u ON b.userid = u.id
	`)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var beats []*model.Beat

	for rows.Next() {
		var beat model.Beat
		beat.User = &model.User{}

		if err := rows.Scan(&beat.ID,
			&beat.User.ID,
			&beat.Timestamp,
			&beat.Location,
			&beat.Song,
			&beat.Artist,
			&beat.Description,
			&beat.Longitude,
			&beat.Latitude,
			&beat.User.ID,
			&beat.User.Name,
			&beat.User.Username,
			&beat.User.Bio); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		beats = append(beats, &beat)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return beats, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*model.User, error) {
	var user model.User
	err := r.db.QueryRow(context.Background(), "SELECT id, name, username, bio FROM users WHERE id = $1", id).Scan(&user.ID, &user.Name, &user.Username, &user.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return &user, nil
}

// Beatdrop is the resolver for the beatdrop field.
func (r *queryResolver) Beatdrop(ctx context.Context, id uuid.UUID) (*model.Beat, error) {
	var beat model.Beat
	beat.User = &model.User{}

	err := r.db.QueryRow(context.Background(), `
	SELECT 
		b.id,
		b.userid,
		b.timestamp,
		b.location,
		b.song,
		b.artist,
		b.description,
		b.longitude,
		b.latitude,
		u.id,
		u.name,
		u.username,
		u.bio
	FROM beats b
	JOIN users u ON b.userid = u.id
	WHERE b.id = $1;`, id).Scan(&beat.ID,
		&beat.User.ID,
		&beat.Timestamp,
		&beat.Location,
		&beat.Song,
		&beat.Artist,
		&beat.Description,
		&beat.Longitude,
		&beat.Latitude,
		&beat.User.ID,
		&beat.User.Name,
		&beat.User.Username,
		&beat.User.Bio)

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return &beat, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, id uuid.UUID) ([]*model.Comment, error) {
	rows, err := r.db.Query(context.Background(), `
	 SELECT
        c.id,
        c.timestamp,
        u.id,
        u.name,
        u.username,
        u.bio,
        c.comment
    FROM comments c
    JOIN users u ON c.userid = u.id
    WHERE c.beatid = $1;`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var comments []*model.Comment

	for rows.Next() {
		var comment model.Comment
		comment.User = &model.User{}

		if err := rows.Scan(
			&comment.ID, &comment.Timestamp, &comment.User.ID, &comment.User.Name, &comment.User.Username, &comment.User.Bio, &comment.Comment); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		comments = append(comments, &comment)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return comments, nil
}

// Beatdrops is the resolver for the beatdrops field.
func (r *queryResolver) Beatdrops(ctx context.Context, id uuid.UUID) ([]*model.Beat, error) {
	rows, err := r.db.Query(context.Background(), `
	SELECT 
		id,
		timestamp,
		location,
		song,
		artist,
		description,
		longitude,
		latitude
	FROM beats WHERE userid = $1;`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var beats []*model.Beat

	for rows.Next() {
		var beat model.Beat
		beat.User = &model.User{}

		if err := rows.Scan(&beat.ID,
			&beat.Timestamp,
			&beat.Location,
			&beat.Song,
			&beat.Artist,
			&beat.Description,
			&beat.Longitude,
			&beat.Latitude,
		); err != nil {
			log.Fatalf("Error scanning row: %v", err)
		}

		beats = append(beats, &beat)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return beats, nil
}

// Friends is the resolver for the friends field.
func (r *queryResolver) Friends(ctx context.Context, id uuid.UUID) ([]*model.Friend, error) {
	rows, err := r.db.Query(ctx, `
		SELECT u.id, u.name, u.username, u.bio, u.photo, f.status
		FROM friends f
		JOIN users u 
		  ON u.id = CASE WHEN f.alpha = $1 THEN f.beta ELSE f.alpha END
		WHERE f.alpha = $1 OR f.beta = $1;`, id)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Query failed: %v\n", err)
	}

	defer rows.Close()

	var friends []*model.Friend
	for rows.Next() {
		var friend model.Friend
		friend.Beta = &model.User{}

		if err := rows.Scan(
			&friend.Beta.Name,
			&friend.Beta.Name,
			&friend.Beta.Username,
			&friend.Beta.Bio,
			&friend.Beta.Photo,
			&friend.Status,
		); err != nil {
			return nil, fmt.Errorf("scan failed: %w", err)
		}
		friends = append(friends, &friend)
	}

	if err != nil {
		log.Fatalf("Error querying user: %v", err)
	}

	return friends, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
